/*
Задача 4. Динамика на дереве (6 баллов)
Дано невзвешенное дерево.
Расстоянием между двумя вершинами будем называть количество ребер в пути,
соединяющем эти две вершины.

Для каждой вершины определите сумму расстояний до всех остальных вершин.
Время работы должно быть O(n).

Формат входных данных:
В первой строке записано количество вершин n ≤ 10000.
Затем следует n – 1 строка, описывающая ребра дерева.
Каждое ребро – это два различных целых числа – индексы вершин в диапазоне
[0, n–1]. Индекс корня – 0. В каждом ребре родительской вершиной является та, чей номер меньше.
Формат выходных данных:
Выход должен содержать n строк.
В i-ой строке выводится сумма расстояний от i-ой вершины до всех остальных.

*/
#include <iostream>
#include <vector>
/*
 Обход в глубину позволяет найти расстояние до вершин, а именно:
     обнуляем текущую дистанцию. Для всех детей данной вершины выполняем
     поиск в глубину для далее стоящих вершин (доходим в итоге до листьев)
     В листе расстояние до следующих вершин равно нулю, но к ним ведет 1 дорога
     Этот факт учитывает number_of_points, которая показывает количество вершин,
     являющихся детьми данной вершины, + сама вершина.(Поэтому начальное значение
     number_of_points = 1, так как сама вершина входит в это число). Далее
     прибавляем количество вершин, записанное в ее детях и получаем искомое number_of_points
     Что касается дистанции, то она равна сумме дистании для ребенка + number_of_points,
     так как для каждого пути у нас добавляется еще одна ветвь, плюс путь до самой вершины
     пример:
              A      (из B 2 пути (BC и BD), длина которых по 1. Из А есть пути в
             /        С и D через B, но их длина на 1 больше, и есть путь в B.
            B         Таким образом, получаем dist[A] = dist[B] + 3
           / \        где 3 - количество вершин (B,C,D))
          C   D
     Таким образом при запуске для 0-ой вершины(корня) получим суммарное расстояние от
     корня до всех листьев.
*/
long long int depth_first_search(int current_point,
                                 std::vector<std::vector<int>> &tree,
                                 std::vector<int> &number_of_points) {
    long long int distance = 0;
    number_of_points[current_point] = 1;
    for (auto point : tree[current_point]) {
        distance += depth_first_search(point, tree, number_of_points) +
                    number_of_points[point];
        number_of_points[current_point]+=number_of_points[point];
    }
    return distance;
}
/*
 Считываем количество элементов и сами ребра.
 В условии было скакзано, что меньший индекс - родитель,
 больший - ребенок. Проверяем это условие и в правильной форме
 помещаем в массивы :
     tree - массив где в [i] лежат номера всех детей
     parent - массив где в [i] лежит номер родителя i-той вершини
 Создаем массив расстояний(так как расстояния выражаются через
 расстояния родителей) и массив number_of_points(см комментарий ранее).
 Считаем суммарное расстояние от корня до всех листьев.
 Теперь перед нами стоит задача посчитать количество для других вершин.
 Путь для всех вершин, не являющихся ребенком рассматриваемой, увеличился на 1,
 а до всех остальных, включая рассматриваемую, уменьшился на 1(до самой себя 0)
 по сравнению с отцовской вершиной.
 Пример:
        A     (Для A расстояние равно 5. Расстояние от B До С и F увеличилось
       / \     на 1 по сравнению с расстоянием от А. А расстояние до D, E и B)
      B   C
     / \   \
    D   E   F
 Тогда конечная формула выглядит как :
    distance[i] = distance[parent[i]] - 1 * number_of_points + (n - number_of_points)
    где n - число всех вершин, n-number_of_points - число всех вершин, у которых
    увеличился путь.

 Доказательство сложности O(n):
     Считываем данные O(n)
     Поиск расстояния для корня O(E+V), Где E = n-1 - количество ребер
                                            V = n - количество вершин
     Финальный цикл O(n-1)
     Итог O(n) + O(2n-1) + O(n-1) = O(n)
*/
int main() {
    int n, parent_number, child_number;
    std::cin >> n;
    std::vector<std::vector<int>> tree(n);
    std::vector<int> parent(n);
    for (int i = 1; i < n; i++) {
        std::cin >> parent_number >> child_number;
        if (child_number < parent_number) {
            long long int tmp = parent_number;
            parent_number = child_number;
            child_number = tmp;
        }
        tree[parent_number].push_back(child_number);
        parent[child_number] = parent_number;
    }
    std::vector<long long int> distance;
    distance.resize(n);
    std::vector<int> number_of_points;
    number_of_points.resize(n);
    distance[0] = depth_first_search(0, tree, number_of_points);
    std::cout << distance[0] <<"\n";
    for (int i = 1; i < n; i++) {
        distance[i] = distance[parent[i]] - 2 * number_of_points[i] + n;
        std::cout << distance[i] <<"\n";
    }
    return 0;
}
