/*
Дано N кубиков. Требуется определить каким количеством способов можно выстроить из этих кубиков пирамиду.
Формат входных данных:
На вход подается количество кубиков N.
Формат выходных данных:
Вывести число различных пирамид из N кубиков.

3_1. Высокая пирамида. Каждый вышележащий слой пирамиды должен быть не больше нижележащего.
N ≤ 200.
*/
#include <iostream>
/*
Алгоритм решения сводится к разбиению числа(представление числа в виде суммы чисел)
Каждому уровню соответствует число. Так как в формуле разбиения числа не важен порядок, то
численно количество вариантов пирамид соответствует разбиению.
Согласно уже полученной рекурсивной формуле для разбиения:
Количество разбиений числа n на слагаемые,
не превышающие k, удовлетворяет рекуррентной формуле:

P(n;k)={P(n;k-1)+P(n-k;k), k <= n,
       {P(n;n), k>n
с начальными значениями:

P(0;0)=1
P(i;0)=0 для всех i>0
При этом количество всевозможных разбиений числа n равно P(n;n)

Соответственно получаем k=limit, n = number и ищем разбиение (n;n);
Для этого создаем таблицу промежуточных значений, которая будет заполняться по мере
обработки, при этом нужна именно таблица значений, так как повторы некоторых рекурсивных
веток займут довольно много времени, поскольку придется проходить по всем значениям от n до 0
и не один раз. Таблица позволяет использовать полученные ранее результаты, что позволяет пройти
лишь раз по всей ветке, а для другой части уже будут значения в таблице.
*/
long long int perestanovki(long long int number,
                           long long int limit,
                           long long int **table) {
    if (table[number][limit] >=0)
        return table[number][limit];
    if (limit<=number) {
        table[number][limit] = perestanovki(number, limit-1, table)
                            + perestanovki(number-limit, limit, table);
    } else {
        table[number][limit] = perestanovki(number, number, table);
    }
    return table[number][limit];
}

int main() {
    long long int n;
    std::cin >> n;
    long long int **table = new long long int*[n+1];
    for (long long int i = 0; i < n+1; i++) {
        table[i]= new long long int[n+1];
        table[i][0] = 0;
        for (long long int j = 1; j < n+1; j++) {
            table[i][j] = -1;
        }
    }
    table[0][0] = 1;
    std::cout << perestanovki(n, n, table);
    for (long long int i = 0; i<n+1; i++) {
        delete [] table[i];
    }
    delete[] table;
    return 0;
}
