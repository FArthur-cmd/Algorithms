/**
 * Штирлиц и Мюллер стреляют по очереди. В очереди n человек, стоящих друг за другом.
 * Каждым выстрелом убивается один из стоящих.
 * Кроме того, если у кого-то из стоящих в очереди убиты все его соседи,
 * то этот человек в ужасе убегает. Проигрывает тот, кто не может ходить.
 * Первым стреляет Штирлиц. Требуется определить, кто выиграет при оптимальной игре обеих сторон,
 * и если победителем будет Штирлиц, то найти все возможные первые ходы, ведущие к его победе.
 *
 *
 * Формат ввода
 *
 * Входной файл содержит единственное число n (2≤ n≤ 5000) — количество человек в очереди.
 *
 *
 * Формат вывода
 *
 * Если выигрывает Мюллер, выходной файл должен состоять из единственного слова Mueller.
 * Иначе в первой строке необходимо вывести слово Schtirlitz,
 * а в последующих строках — номера людей в очереди,
 * которых мог бы первым ходом убить Штирлиц для достижения своей победы.
 * Номера необходимо выводить в порядке возрастания.
 */
#include <iostream>
#include <vector>

// Максимальная длина из условия
const uint32_t MAX_LENGTH = 5000;


/*
 * Класс игры
 * Инициализирует данные:
 *     -число людей в очереди
 *     -вычисляемая функция
 *     -результаты по вычислению функции на текущем шаге
 * Обработка (calculate)
 *     -проверяем все варианты выбора
 *     -для каждого получаем разбиение игры на две(левее и правее выбранного)
 *     -так как количество в новых играх строго меньше текущего, то ранее уже
 *      был посчитан результат для функции, а значит, нам достаточно сделать
 *      исключающее или (xor) для получения объединения игр.
 *     -Для вычисления функции требуется найти минимум из непосещенных значений.
 *      Для этого воспользуемся result в котором будем хранить все посещенные
 *      на этом шаге варианты. Так как обнулять массив на каждом шаге будет долгой
 *      операцией (O(n)), то можно хранить текущий шаг и помечать, что изменения
 *      произошли именно на этом шаге, а не на предыдущих. Тогда достаточно будет идти
 *      по массиву, начиная с нулевого элемента и искать первый встретившийся ноль.
 *      Индекс этого нуля и будет результатом вычисления функции
 * Вывод (согласно требуемому формату)
 *     -Проверяем выиграли ли мы или проиграли. Если выиграли, перебераем все варианты
 *      элементов, по которым разбивая очередь мы будем получать игру, в которой выигрываем.
 *      Необходимо, чтобы сумма игры была проигрышной, то есть соперник проиграл.
 *      Эта проверка осуществляется простым неравенством нулю функции от объединения игр.
 *      Тогда достаточно проверить, что XOR от значений функций меньших игр не равен нулю.
 */
class CruelGame {
public:
    CruelGame();

    explicit CruelGame(uint32_t n);

    explicit CruelGame(std::istream &in);

    void PrintResult(std::ostream &out);

private:
    void Calculate();

    // Будем отслеживать победу Штирлица, поэтому функция Шпрага-Ганди не равна нулю для победы
    static bool CanWin(uint32_t number);

    static uint32_t GameSum(uint32_t first, uint32_t second);

    uint32_t queue_count_;
    std::vector<uint32_t> shprag_grandi_;
    std::vector<uint32_t> results_;
};

bool CruelGame::CanWin(uint32_t number) {
    return (number != 0);
}

uint32_t CruelGame::GameSum(uint32_t first, uint32_t second) {
    return (first ^ second);
}

CruelGame::CruelGame() : queue_count_(MAX_LENGTH), shprag_grandi_(MAX_LENGTH + 1, 0),
                         results_(MAX_LENGTH + 1, 0) {}

CruelGame::CruelGame(uint32_t n) : queue_count_(n), shprag_grandi_(MAX_LENGTH + 1, 0),
                                   results_(MAX_LENGTH + 1, 0) {}

CruelGame::CruelGame(std::istream &in) : shprag_grandi_(MAX_LENGTH + 1, 0),
                                         results_(MAX_LENGTH + 1, 0) {
    in >> queue_count_;
}

void CruelGame::PrintResult(std::ostream &out) {
    Calculate();

    if (CanWin(shprag_grandi_[queue_count_])) {
        out << "Schtirlitz";
        for (size_t i = 0; i < queue_count_; ++i) {
            if (!CanWin(GameSum(shprag_grandi_[i], shprag_grandi_[queue_count_ - i - 1]))) {
                out << "\n" << i + 1;
            }
        }
    } else {
        out << "Mueller";
    }
}

void CruelGame::Calculate() {
    uint32_t current_step = 1;
    uint32_t min_index = 0;

    // Так как если мы приведем ситуация в 0 или 1 мы сразу же выигрываем
    // (0 - очевидно. 1 - был сосед, так как мы стартуем с числа больше, чем 1).
    // Тогда пометим эти элементы 0 (то есть проигрышем). Так как у выигрышных
    // позиций должны быть пути в проигрышный, для соперника, вариант.
    // (то есть если в начале нашего хода мы имеем 0 или 1, то соперник уже победил)

    for (uint32_t i = 2; i <= queue_count_; ++i) {
        // Проверим все разбиения по j+1 элементу.
        // Тогда надо сравнить то, что левее и правее него
        // Пометим все измененные элементы.
        for (uint32_t j = 0; j < i; ++j) {
            results_[GameSum(shprag_grandi_[j], shprag_grandi_[i - j - 1])] = current_step;
        }

        while (results_[min_index] == current_step) {
            ++min_index;
        }

        shprag_grandi_[i] = min_index;
        min_index = 0;
        ++current_step;
    }
}

int main() {
    CruelGame game(std::cin);
    game.PrintResult(std::cout);
}