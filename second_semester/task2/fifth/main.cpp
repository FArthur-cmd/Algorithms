/*
 * Рик решил на день почувствовать себя бизнесменом!
 * В городе есть несколько обменников валюты. В рамках данной задачи считаем,
 * что каждый обменник специализируется только на двух валютах и может
 * производить операции только с ними. Возможно, существуют обменники,
 * специализирующиеся на одинаковых парах валют. В каждом обменнике — свой обменный курс:
 * курс обмена A на B — это количество единиц валюты B, выдаваемое за 1 единицу валюты A.
 * Также в каждом обменнике есть комиссия — сумма, которую вы должны заплатить,
 * чтобы производить операцию. Комиссия взимается в той валюте, которую меняет клиент.
 *
 * Например, если вы хотите поменять 100 долларов США на русские рубли в обменнике,
 * где курс обмена равен 29.75, а комиссия равна 0.39, вы получите
 * (100 - 0.39) ⋅ 29.75 = 2963.3975 рублей (эх, были времена).
 *
 * Вы точно знаете, что в городе используется всего N валют.
 * Пронумеруем их числами 1, 2, …, N. Тогда каждый обменник
 * представляют 6 чисел: целые A и B — номера обмениваемых валют,
 * а также вещественные RAB, CAB, RBA и CBA — обменные курсы и комиссии
 * при переводе из A в B и из B в A соответственно.
 *
 * Рик обладает некоторой суммой в валюте S. Он задаётся вопросом,
 * можно ли, после нескольких операций обмена увеличить свой капитал.
 * Конечно, он хочет, чтобы в конце его деньги вновь были в валюте S.
 * Помогите ему ответить на его вопрос. Рик должен всегда должен иметь
 * неотрицательную сумму денег
 *
 * Формат ввода
 *
 * Первая строка содержит четыре числа: N — количество валют,
 * M — количество обменников, S — валюта, которой располагает Рик,
 * и V — количество единиц этой валюты. Следующие M строк содержат по 6 чисел,
 * которые задают описание соответствующих обменников в описанном выше формате.
 * Числа разделяются одним или несколькими пробелами. Выполняются ограничения ,
 * V — вещественное число
 *
 * В каждом обменнике курсы обмена и комиссии — вещественные числа,
 * задаваемые с точностью не выше двух знаков после запятой в десятичном представлении
 *
 * Назовём последовательность операций обмена простой,
 * если каждый обменник используется в ней не более одного раза.
 * Вы можете считать, что отношение итоговой суммы Рика к исходной не будет превосходить
 * 104 при любой простой последовательности операций.
 *
 * Формат вывода
 *
 * Если Рик может увеличить свой капитал, выведите YES, иначе выведите NO.
 */
#include <iostream>
#include <vector>

/*
 * Структура ребро содержит информацию о ребре (откуда, куда, коэффициенты для вычисления)
 */
struct edge{
    int from, to;
    double rate, comission;
    edge (int from_, int to_, double rate_, double comission_) {
        from = from_;
        to = to_;
        rate = rate_;
        comission = comission_;
    }
};

/*
 * Граф, вершинами которого являются типы валют, а путями - ребра обмена валют
 *
 * С помощью алгоритма Форда-Беллмана находим способ обогатиться, а именно:
 *     заполняем массив результатов нулями, кроме нашей стартовой вершины
 *     Идем по ребрам и если начало ребра не нулевое, то проверяем, можем ли мы увеличить
 *     наш бюджет в другом типе валют.
 *     Продолжаем эту операцию, пока 1) не увеличили исходную точку(достигли желаемого)
 *                                   2) можем что-то улучшить в рехультатах
 *     Если первое не было достигнуто и улучшить ничего не можем, то нет способа обогатиться
 */
class Graph {
private:
    std::vector<edge> courses;
public:
    void add_course(const int &from, const int &to, const double &rate, const double &comission) {
        courses.push_back(edge(from, to, rate, comission));
    }
    bool exist(const int &start_value, const double &start_sum, const int &edges_count, const int &vertex_count) {
        std::vector<double> results(vertex_count + 1, 0);
        results[start_value] = start_sum;
        bool anything_was_modified;
        for (;;) {
            anything_was_modified = false;
            for (int j = 0; j < (edges_count * 2); ++j) {
                if (results[courses[j].from] > 0) {
                    if (results[courses[j].to] < (results[courses[j].from] - courses[j].comission) * courses[j].rate) {
                        if (courses[j].to == start_value) {
                            return true;
                        }
                        results[courses[j].to] = (results[courses[j].from] - courses[j].comission) * courses[j].rate;
                        anything_was_modified = true;
                    }
                }
            }
            if (!anything_was_modified) {
                break;
            }
        }
        return false;
    }
};

int main() {
    int N, M, S, first, second;
    double V, rate_first, rate_second, comission_first, comission_second;
    std::cin >> N >> M >> S >> V;
    Graph course;
    for (int i = 0; i < M; ++i) {
        std::cin >> first >> second >> rate_first >> comission_first >> rate_second >> comission_second;
        course.add_course(first, second, rate_first, comission_first);
        course.add_course(second, first, rate_second, comission_second);
    }
    if (course.exist(S, V, M, N)) {
        std::cout << "YES";
    } else {
        std::cout << "NO";
    }
    return 0;
}
