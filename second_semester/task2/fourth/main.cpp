/*
 * Рик отправляет Морти в путешествие по N вселенным.
 * У него есть список всех существующих однонаправленных телепортов.
 * Чтобы Морти не потерялся, Рику необходимо узнать,
 * между какими вселенными существуют пути, а между какими нет.
 * Помогите ему в этом!
 *
 * Формат ввода
 *
 * На первой строке задано количество вселенных N (1 ≤ N ≤ 1000).
 * Следующие N строк имеют длину N, состоят из нулей и единиц и задают матрицу смежности вселенных.
 * Единица в i-й строке j-м столбце обозначает телепорт из i-й вселенной в j-ю
 *
 * Формат вывода
 *
 * Выведите матрицу, где единица в i-й строке j-м столбце
 * обозначает существование пути из i-й вселенной в j-ю и ноль — его отсутствие.
 */
#include <iostream>
#include <vector>
#include <string>
/*
 * Используем Алгоритм транзитивного замыкания, оптимизированный использованием битовых масок
 *
 * Мы используем не массив из символов, а рассматриваем наборы нулей и единиц как число в двоичной системе
 * Это позволяет сделать последний цикл в 64 раза меньше и асимптотика превращается в О(n^3/64)
 *
 * Сам алгоритм просто проверяет, если есть путь из i в k и путь из k в j, то есть путь из i в j
 */
void transitive_clousure(std::vector<std::vector<unsigned long long>> &matrix, const int &N) {
    for (int k = 0; k < N; ++k) {
        for (int i = 0; i < N; ++i) {
            if ((matrix[i][k/64] >> (63 - k % 64)) % 2 == 1) {
                for (size_t j = 0; j < (N/64 + (N%64 > 0)); ++j) {
                    matrix[i][j] = matrix[i][j] | matrix[k][j];
                }
            }
        }
    }
}


int main() {
    size_t N;
    std::cin >> N;
    std::vector<std::vector<unsigned long long>> matrix;
    matrix.resize(N);
    for (size_t i = 0; i < N; ++i) {
        matrix[i].resize(N/64 + (N%64 > 0), 0);
    }
    std::string line;
    for (size_t i = 0; i < N; ++i) {
        std::cin >> line;
        for (size_t j = 0; j < line.size(); ++j) {
            matrix[i][j/64] += (static_cast<unsigned long long>(line[j] - '0')) << (63 - j%64);
        }
    }
    transitive_clousure(matrix, N);
    for (size_t i = 0; i < N; ++i) {
        for (size_t j = 0; j < N; ++j) {
            std::cout << (((matrix[i][j/64]) >> (63 - j%64)) % 2);
        }
        std::cout << std::endl;
    }
    return 0;
}
